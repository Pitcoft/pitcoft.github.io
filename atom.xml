<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pitcoft - Catch the tail of time.</title>
  
  <subtitle>Walk steps step by step</subtitle>
  <link href="https://pitcoft.com/atom.xml" rel="self"/>
  
  <link href="https://pitcoft.com/"/>
  <updated>2020-10-30T15:24:12.032Z</updated>
  <id>https://pitcoft.com/</id>
  
  <author>
    <name>Pitcoft</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>刷题笔记-leetcode 925.长按键入</title>
    <link href="https://pitcoft.com/2020/10/30/leetcode-925-%E9%95%BF%E6%8C%89%E9%94%AE%E5%85%A5/"/>
    <id>https://pitcoft.com/2020/10/30/leetcode-925-%E9%95%BF%E6%8C%89%E9%94%AE%E5%85%A5/</id>
    <published>2020-10-30T14:00:55.000Z</published>
    <updated>2020-10-30T15:24:12.032Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h3><p><a href="https://leetcode-cn.com/problems/long-pressed-name/">https://leetcode-cn.com/problems/long-pressed-name/</a></p><h3 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h3><p>你的朋友正在使用键盘输入他的名字 <code>name</code>。偶尔，在键入字符 <code>c</code> 时，按键可能会被长按，而字符可能被输入 1 次或多次。</p><p>你将会检查键盘输入的字符 <code>typed</code>。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 <code>True</code>。</p><h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><blockquote><p><strong>输入</strong>：name = “alex”, typed = “aaleex”<br><strong>输出</strong>：true<br><strong>解释</strong>：’alex’ 中的 ‘a’ 和 ‘e’ 被长按。</p></blockquote><h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><blockquote><p><strong>输入</strong>：name = “saeed”, typed = “ssaaedd”<br><strong>输出</strong>：false<br><strong>解释</strong>：’e’ 一定需要被键入两次，但在 typed 的输出中不是这样。</p></blockquote><h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h4><blockquote><p><strong>输入</strong>：name = “leelee”, typed = “lleeelee”<br><strong>输出</strong>：true</p></blockquote><h4 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a>示例 4：</h4><blockquote><p><strong>输入</strong>：name = “laiden”, typed = “laiden”<br><strong>输出</strong>：ture<br><strong>解释</strong>：长按名字中的字符并不是必要的。</p></blockquote><h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h4><ol><li><code>name.length &lt;= 1000</code></li><li><code>typed.length &lt;= 1000</code></li><li><code>name</code> 和 <code>typed</code> 的字符都是小写字母。</li></ol><h3 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h3><h4 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h4><p>题意为<code>name</code>为正常输入，<code>typed</code>可能存在某个字符长按连续键入多次。即需求为判断<code>typed</code>是长按连续键入还是错误键入。</p><p>可以用双指针分别遍历<code>name</code>和<code>typed</code>，判断两者是否符合条件，具体思路为：</p><ul><li>定义<code>p</code>，<code>q</code>两个指针，分别指向<code>name</code>和<code>typed</code>字符串的首个字符。</li><li>当两者指针指向同一个字符时，说明字符匹配，<code>p</code>，<code>q</code>都往后移动一个字符。</li><li>当两者指针指向字符不匹配，分两种情况：<ul><li>如果<code>q</code>指针指向字符<strong>等于</strong><code>q</code>指针后移一位指向的字符，表示该字符是<strong>连续键入</strong>。</li><li>如果<code>q</code>指针指向字符<strong>不等于</strong><code>q</code>指针后移一位指向的字符，表示该字符是<strong>错误键入</strong>。</li></ul></li><li>最后判断当<code>j=0</code>时即跳出循环时，<code>typed</code>已经遍历完，而<code>name</code>仍未遍历完，两者必不相等，直接返回<code>False</code>。</li></ul><h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><p>时间复杂度：$O(M+N)$，分别遍历<code>name</code>和<code>typed</code>两个字符串。<br>空间复杂度：$O(1)$，常数个辅助变量。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isLongPressedName</span>(<span class="hljs-params">self, name: str, typed: str</span>) -&gt; bool:</span>        m, n = len(name), len(typed)        <span class="hljs-comment"># 定义两个指针，分别指向name和typed的首字符</span>        i, j = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>        <span class="hljs-comment"># 遍历typed到尾字符</span>        <span class="hljs-keyword">while</span> j &lt; n:            <span class="hljs-comment"># 两个指针同时指向字符相等，两指针后移</span>            <span class="hljs-keyword">if</span> i &lt; m <span class="hljs-keyword">and</span> name[i] == typed[j]:                i += <span class="hljs-number">1</span>                j += <span class="hljs-number">1</span>            <span class="hljs-comment"># j = 0时不满足首字符相等，name和typed首字符不相等，直接返回False</span>            <span class="hljs-comment"># j &gt; 0时指针指向字符等于下一个字符，j指针后移，继续判断</span>            <span class="hljs-comment"># j &gt; 0时指针指向字符不等于下一个字符，代表错误输入了字符，直接返回False</span>            <span class="hljs-keyword">elif</span> j &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> typed[j] == typed[j<span class="hljs-number">-1</span>]:                j += <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-comment"># 最后跳出循环(代表typed已经遍历完了)，判断name是否遍历完，完则True，否则返回False。</span>        <span class="hljs-keyword">return</span> i == m</code></pre><h3 id="方法二：单指针"><a href="#方法二：单指针" class="headerlink" title="方法二：单指针"></a>方法二：单指针</h3><h4 id="思路分析：-1"><a href="#思路分析：-1" class="headerlink" title="思路分析："></a>思路分析：</h4><p>题目说明name和typed均为小写字母，设置一个单指针，指向<code>typed</code>首字符，用<code>i</code>表示name字符的索引，具体步骤：</p><ul><li>遍历<code>typed</code>，字符串<code>type</code>与<code>name</code>对应字符相等，则<code>i</code>加一，继续遍历<code>typed</code>。</li><li>当字符串<code>type</code>与<code>name</code>对应字符<strong>不相等</strong>，则：<ul><li>当前字符与前一个字符<strong>相等</strong>，表示该字符是<strong>连续键入</strong>，继续往后遍历。</li><li>当前字符与前一个字符<strong>不相等</strong>，表示该字符是<strong>错误键入</strong>，直接返回False。</li></ul></li><li>最后<code>typed</code>遍历结束时，判断<code>name</code>是否走完，若<code>name</code>仍未遍历完，两者必不相等，直接返回<code>False</code>。<blockquote><p>例子：name = “pitcoft”, typed = “pit”</p></blockquote></li></ul><p><strong>注意边界问题</strong>：</p><blockquote><p>例子：name = “a”, typed = “aaa”</p></blockquote><ul><li><strong>问题</strong>：如果按以上执行此例子，会报错，原因是第一个字符匹配后，<code>i = 1</code>，导致下一次判断<code>name[1]</code>不存在。</li><li><strong>解决办法</strong>：在<code>name</code>后面加上一个辅助字符串<code>“$”</code>，这样<code>i = 1</code>时能读取到<code>“$”</code>进而满足<code>type = name[i-1]</code>。</li></ul><h4 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><p>时间复杂度：$O(M+N)$，分别遍历<code>S</code>和<code>T</code>两个字符串<br>空间复杂度：$O(1)$</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isLongPressedName</span>(<span class="hljs-params">self, name: str, typed: str</span>) -&gt; bool:</span>        i = <span class="hljs-number">0</span>         name += <span class="hljs-string">&quot;$&quot;</span>        <span class="hljs-keyword">for</span> type <span class="hljs-keyword">in</span> typed:            <span class="hljs-keyword">if</span> type == name[i]:<span class="hljs-comment"># 当前字符相等，后移继续判断</span>                i += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> type != name[i<span class="hljs-number">-1</span>]:<span class="hljs-comment"># 当前字符与前一位不等，直接返回False，相等则继续判断</span>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> i == len(name) - <span class="hljs-number">1</span> <span class="hljs-comment">#减一是因为加了辅助的$</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/long-pressed-name/&quot;&gt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://pitcoft.com/categories/leetcode/"/>
    
    
    <category term="双指针" scheme="https://pitcoft.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="字符串" scheme="https://pitcoft.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>刷题笔记-leetcode 561.数组拆分I</title>
    <link href="https://pitcoft.com/2020/10/27/leetcode-561-%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86-I/"/>
    <id>https://pitcoft.com/2020/10/27/leetcode-561-%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86-I/</id>
    <published>2020-10-27T15:01:01.000Z</published>
    <updated>2020-10-28T16:03:30.584Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h3><p><a href="https://leetcode-cn.com/problems/array-partition-i/">https://leetcode-cn.com/problems/array-partition-i/</a></p><h3 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h3><p>给定长度为 <strong>2n</strong> 的数组, 你的任务是将这些数分成 <strong>n</strong> 对, 例如 <strong>(a1, b1), (a2, b2), …, (an, bn)</strong> ，使得从1 到 n 的 <strong>min(ai, bi)</strong> 总和最大。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><blockquote><p><strong>输入</strong> : [1,4,3,2]</p><p><strong>输出</strong> : 4<br><strong>解释</strong> : n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4).</p></blockquote><p><strong>提示：</strong></p><pre><code>1. n 是正整数,范围在 [1, 10000].2. 数组中的元素范围在 [-10000, 10000].</code></pre><h3 id="方法：数组排序"><a href="#方法：数组排序" class="headerlink" title="方法：数组排序"></a>方法：数组排序</h3><h4 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h4><p>题目需求是将长度2n的数组拆成n对，在每个队里取最小值，然后相加取得一个最大值。</p><p>例如：<code>[1,4,3,2]</code>拆成2对，与最小数<code>1</code>匹配的数，<code>1</code>是一定可以取到的，与最大数<code>4</code>匹配，取到的一定是另外的数。</p><ul><li>所以要达到收益最大化，必须为最小数匹配第二小的数；最大数匹配第二大的数。</li></ul><p><strong>具体操作：</strong></p><ul><li>做数组的原地快速排序。</li><li>取下标为偶数的值求和即可。</li></ul><h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><p><code>sorted</code>函数内部实现机制为：<code>Timsort</code></p><p>时间复杂度：$O(nlog(n))$，<code>Timsort</code>算法的时间复杂度。<br>空间复杂度：$O(n)$</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arrayPairSum</span>(<span class="hljs-params">self, nums: List[int]</span>) -&gt; int:</span>        sum = <span class="hljs-number">0</span>        nums.sort()        <span class="hljs-keyword">for</span> i,item <span class="hljs-keyword">in</span> enumerate(nums):            <span class="hljs-keyword">if</span> i%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>: <span class="hljs-comment"># 取下标为偶数的值</span>                sum += item <span class="hljs-comment"># 求和</span>        <span class="hljs-keyword">return</span> sum</code></pre><h4 id="精简代码："><a href="#精简代码：" class="headerlink" title="精简代码："></a>精简代码：</h4><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arrayPairSum</span>(<span class="hljs-params">self, nums</span>) -&gt; int:</span>        <span class="hljs-keyword">return</span> sum(sorted(nums)[::<span class="hljs-number">2</span>]) <span class="hljs-comment"># 对数组排序，隔2取一个数并求和</span></code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>与最大与第二大匹配就可以保留第二大的数字（目的就是尽量保留大的数）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/array-partition-i/&quot;&gt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://pitcoft.com/categories/leetcode/"/>
    
    
    <category term="数组" scheme="https://pitcoft.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="排序" scheme="https://pitcoft.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>刷题笔记-leetcode 19.删除链表的倒数第N个节点</title>
    <link href="https://pitcoft.com/2020/10/26/leetcode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>https://pitcoft.com/2020/10/26/leetcode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</id>
    <published>2020-10-26T15:09:58.000Z</published>
    <updated>2020-10-28T15:11:52.096Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h3><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</a></p><h3 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h3><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><blockquote><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p></blockquote><p><strong>说明：</strong><br>    给定的 n 保证是有效的。<br><strong>进阶：</strong><br>    你能尝试使用一趟扫描实现吗？</p><h3 id="方法一：快慢指针（一次遍历）"><a href="#方法一：快慢指针（一次遍历）" class="headerlink" title="方法一：快慢指针（一次遍历）"></a>方法一：快慢指针（一次遍历）</h3><h4 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h4><p>题目需求是寻找倒数第n个节点，所以我们可以设置两个指针<code>slow</code>和<code>fast</code>对链表进行遍历，<code>fast</code>先走n步的，当<code>fast</code>走到链表末尾时，<code>slow</code>正好为待删除节点的前驱节点。</p><p><strong>具体操作：</strong></p><ul><li>初始<code>slow</code>和<code>fast</code>指针均指向哑节点。</li><li>先使用<code>fast</code>指针遍历n次链表，即<code>fast</code>指针与<code>slow</code>指针相隔n-1个节点。</li><li>再同时使用<code>fast</code>指针和<code>slow</code>指针遍历链表，当<code>fast</code>遍历到链表的末尾时（即<code>fast.next</code>为空指针），<code>slow</code>为倒数第n个节点的前驱节点（即<code>slow.next</code>为待删除节点）。</li></ul><h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><p>时间复杂度：$O(L)$，<code>L</code>为该链表长度。<br>空间复杂度：$O(1)$，一次遍历。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">removeNthFromEnd</span>(<span class="hljs-params">self, head: ListNode, n: int</span>) -&gt; ListNode:</span>        dummy = ListNode(<span class="hljs-number">0</span>) <span class="hljs-comment"># 设置哑节点</span>        dummy.next = head        slow, fast = dummy, dummy <span class="hljs-comment"># 快慢指针指向哑节点</span>        <span class="hljs-comment"># 快指针先走n步</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):            fast = fast.next        <span class="hljs-comment"># 快慢指针同时走，直到fast指针到链表尾部，slow为待删除节点前驱节点</span>        <span class="hljs-keyword">while</span> fast.next:            slow = slow.next            fast = fast.next        <span class="hljs-comment"># 删除节点</span>        slow.next = slow.next.next        <span class="hljs-keyword">return</span> dummy.next</code></pre><h3 id="方法二：递归迭代"><a href="#方法二：递归迭代" class="headerlink" title="方法二：递归迭代"></a>方法二：递归迭代</h3><h4 id="思路分析：-1"><a href="#思路分析：-1" class="headerlink" title="思路分析："></a>思路分析：</h4><p>通过递归的函数<code>head.next= self.removeNthFromEnd(head.next, n)</code>从后往前计数，每次向前加一，如果<code>count != n</code>时，返回该节点<code>return head</code>，继续往前递归，当<code>count == n</code>时，返回该节点的<code>next</code>给递归的函数（也就是跳过待删除函数，传递的是待删除的函数的<code>next</code>）。</p><h4 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><p>时间复杂度：$O(L)$，<code>L</code>为该链表长度。<br>空间复杂度：$O(1)$，一次遍历。</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">removeNthFromEnd</span>(<span class="hljs-params">self, head: ListNode, n: int</span>) -&gt; ListNode:</span>        <span class="hljs-keyword">global</span> count <span class="hljs-comment"># 递归时count要赋值</span>        <span class="hljs-keyword">if</span> head <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            count = <span class="hljs-number">0</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        <span class="hljs-keyword">else</span>:            head.next= self.removeNthFromEnd(head.next, n) <span class="hljs-comment"># 递归调用</span>            count += <span class="hljs-number">1</span> <span class="hljs-comment"># 回溯时节点的计数</span>            <span class="hljs-keyword">return</span> head.next <span class="hljs-keyword">if</span> count ==n <span class="hljs-keyword">else</span> head <span class="hljs-comment"># 删除节点</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-nth-node-from</summary>
      
    
    
    
    <category term="leetcode" scheme="https://pitcoft.com/categories/leetcode/"/>
    
    
    <category term="链表" scheme="https://pitcoft.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="双指针" scheme="https://pitcoft.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="递归" scheme="https://pitcoft.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>刷题笔记-leetcode 844.比较含退格的字符串</title>
    <link href="https://pitcoft.com/2020/10/20/leetcode-844-%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://pitcoft.com/2020/10/20/leetcode-844-%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-10-20T15:24:28.000Z</published>
    <updated>2020-10-27T15:30:04.968Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h3><p><a href="https://leetcode-cn.com/problems/backspace-string-compare/">https://leetcode-cn.com/problems/backspace-string-compare/</a></p><h3 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h3><p>给定 <code>S</code> 和 <code>T</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 <code>#</code> 代表退格字符。</p><p><strong>注意</strong>：如果对空文本输入退格字符，文本继续为空。</p><h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><blockquote><p>输入：S = “ab#c”, T = “ad#c”<br>输出：true<br>解释：S 和 T 都会变成 “ac”。</p></blockquote><h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><blockquote><p>输入：S = “ab##”, T = “c#d#”<br>输出：true<br>解释：S 和 T 都会变成 “”。</p></blockquote><h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h4><blockquote><p>输入：S = “a##c”, T = “#a#c”<br>输出：true<br>解释：S 和 T 都会变成 “c”。</p></blockquote><h4 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a>示例 4：</h4><blockquote><p>输入：S = “a#c”, T = “b”<br>输出：false<br>解释：S 会变成 “c”，但 T 仍然是 “b”。</p></blockquote><h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h4><p><code>1 &lt;= S.length &lt;= 200</code><br><code>1 &lt;= T.length &lt;= 200</code><br><code>S</code> 和 <code>T</code> 只含有小写字母以及字符<code> &#39;#&#39;</code>。</p><h3 id="方法一：字符串重构（栈）"><a href="#方法一：字符串重构（栈）" class="headerlink" title="方法一：字符串重构（栈）"></a>方法一：字符串重构（栈）</h3><h4 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h4><p>当字符串碰见退格符<code>#</code>的时，将退格符与前一个字符串一并删除，最终返回删除后的字符串并比较两个字符串是否相等，当遍历字符串时：</p><ul><li>如果是一般的字符，则压栈。</li><li>如果是退格符<code>#</code>，则把栈顶元素弹出。</li><li>遍历结束把栈元素用<code>join</code>函数连接成字符串</li></ul><h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><p>时间复杂度：$O(M+N)$，分别遍历<code>S</code>和<code>T</code>两个字符串<br>空间复杂度：$O(M+N)$</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params">object</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backspaceCompare</span>(<span class="hljs-params">self, S, T</span>):</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inputStr</span>(<span class="hljs-params">str</span>):</span>            stack = list()            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> str:                <span class="hljs-comment"># 判断为普通字符则压栈</span>                <span class="hljs-keyword">if</span> i != <span class="hljs-string">&#x27;#&#x27;</span>:                    stack.append(i)                <span class="hljs-comment"># 为#且栈不为空则栈顶出栈</span>                <span class="hljs-keyword">elif</span> stack != []:                    stack.pop()            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(stack[:])        <span class="hljs-keyword">return</span> inputStr(S) == inputStr(T)</code></pre><h3 id="方法二：双指针"><a href="#方法二：双指针" class="headerlink" title="方法二：双指针"></a>方法二：双指针</h3><h4 id="思路分析：-1"><a href="#思路分析：-1" class="headerlink" title="思路分析："></a>思路分析：</h4><p>当遇见<code>#</code>字符时，会删除其前一个字符，也就是说，<code>#</code>的影响仅限于删除它的前一个字符而不会影响到其他字符，因此我们可以用逆序遍历整个字符串，当存在<code>#</code>字符时，就可以判断是否要删除前一个字符。具体步骤：</p><ol><li><p>定义双指针，分别指向<code>S</code>和<code>T</code>两个字符串的末尾。</p></li><li><p>定义变量count，记录<code>#</code>出现的次数（也就是待删除元素的数量）。</p><p>遍历字符串的每一个字符，如果该字符：</p></li></ol><ul><li>为<code>#</code>字符，则记录的变量count加1</li><li>为普通字符，则：<ul><li>count = 0时，表示该字符不需要删除。</li><li>count &gt; 0时，该字符删除，并且count减1。</li></ul></li></ul><p>按以上逆序遍历两个字符串，会碰见以下三种情况：</p><ul><li>count为0，且两个指针同时指向普通字符，判断两字符是否相等，不等返回False，相等继续判断。<pre><code class="hljs python"><span class="hljs-keyword">if</span> p &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> q &gt;= <span class="hljs-number">0</span>:<span class="hljs-keyword">if</span> S[p] != T[q]:<span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></li><li>当一个字符串遍历完成，代表该字符串为“ ”，条件为<code>p &lt; 0 or q &lt; 0</code>，并且另一个字符串仍未遍历完（也就是已经跳出循环，处于在等待判断普通字符是否与另一个字符串相等的阶段），这时候两个字符串是不可能相等的（一个空，另一个的字符串在等待判断）,直接返回<code>False</code>。<pre><code class="hljs python"><span class="hljs-keyword">elif</span> p &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> q &gt;= <span class="hljs-number">0</span>:<span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></li><li>两个字符串遍历完成，则<code>p</code>与<code>q</code>都 &lt; 0，代表字符串都为“ ”。返回<code>True</code>。</li></ul><h4 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><p>时间复杂度：$O(M+N)$，分别遍历<code>S</code>和<code>T</code>两个字符串<br>空间复杂度：$O(1)$</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backspaceCompare</span>(<span class="hljs-params">self, S: str, T: str</span>) -&gt; bool:</span>        <span class="hljs-comment"># 定义双指针</span>        p, q = len(S) - <span class="hljs-number">1</span>, len(T) - <span class="hljs-number">1</span>        <span class="hljs-comment"># 定义变量记录 &#x27;#&#x27; 的数量</span>        count_S, count_T = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> p &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> q &gt;= <span class="hljs-number">0</span>:            <span class="hljs-comment"># 遍历字符串 S</span>            <span class="hljs-keyword">while</span> p &gt;= <span class="hljs-number">0</span>:                <span class="hljs-comment"># 字符为 &#x27;#&#x27;，count_S 加 1，p指针左移</span>                <span class="hljs-keyword">if</span> S[p] == <span class="hljs-string">&#x27;#&#x27;</span>:                    count_S += <span class="hljs-number">1</span>                    p -= <span class="hljs-number">1</span>                <span class="hljs-comment"># 字符为普通字符，count_S&gt;0，删除该字符，count_S，p左移继续遍历</span>                <span class="hljs-keyword">elif</span> count_S &gt; <span class="hljs-number">0</span>:                    count_S -= <span class="hljs-number">1</span>                    p -= <span class="hljs-number">1</span>                <span class="hljs-comment"># 字符为普通字符，count_S=0，跳出循环，等待与另一个字符串判断</span>                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">break</span>            <span class="hljs-comment"># 遍历字符串 T</span>            <span class="hljs-keyword">while</span> q &gt;= <span class="hljs-number">0</span>:                <span class="hljs-keyword">if</span> T[q] == <span class="hljs-string">&#x27;#&#x27;</span>:                    count_T += <span class="hljs-number">1</span>                    q -= <span class="hljs-number">1</span>                <span class="hljs-keyword">elif</span> count_T &gt; <span class="hljs-number">0</span>:                    count_T -= <span class="hljs-number">1</span>                    q -= <span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">break</span>            <span class="hljs-comment"># 判断字符串两个未遍历完，跳出循环时，两个指针对应的字符是否相等</span>            <span class="hljs-keyword">if</span> p &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> q &gt;= <span class="hljs-number">0</span>:                <span class="hljs-keyword">if</span> S[p] != T[q]:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-comment"># 只有一个字符串遍历完，另一个跳出循环</span>            <span class="hljs-keyword">elif</span> p &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> q &gt;= <span class="hljs-number">0</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            p -= <span class="hljs-number">1</span>            q -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/backspace-string-com</summary>
      
    
    
    
    <category term="leetcode" scheme="https://pitcoft.com/categories/leetcode/"/>
    
    
    <category term="双指针" scheme="https://pitcoft.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="栈" scheme="https://pitcoft.com/tags/%E6%A0%88/"/>
    
  </entry>
  
</feed>
