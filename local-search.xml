<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HTTP协议详解笔记</title>
    <link href="/2021/01/19/HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/01/19/HTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="HTTP协议简介"><a href="#HTTP协议简介" class="headerlink" title="HTTP协议简介"></a>HTTP协议简介</h3><p>超文本传输协议（英文：Hyper Text Transfer Protocol，HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。HTTP有很多应用，但最著名的是用于web浏览器和web服务器之间的双工通信。</p><p>HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。</p><p>2014年12月，互联网工程任务组（IETF）的Hypertext Transfer Protocol Bis（httpbis）工作小组将HTTP/2标准提议递交至IESG进行讨论，于2015年2月17日被批准。 HTTP/2标准于2015年5月以RFC 7540正式发表，取代HTTP 1.1成为HTTP的实现标准。</p><p>推荐书籍：<a href="https://book.douban.com/subject/10746113/">HTTP权威指南</a></p><h3 id="HTTP协议概述"><a href="#HTTP协议概述" class="headerlink" title="HTTP协议概述"></a>HTTP协议概述</h3><p>HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。</p><p>尽管TCP/IP协议是互联网上最流行的应用，HTTP协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在TCP/IP协议族使用TCP作为其传输层。</p><p>通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。</p><h3 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h3><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p><p>以下是 HTTP 请求/响应的步骤：</p><ol><li><p>客户端连接到Web服务器<br>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="https://pitcoft.com/">https://pitcoft.com/</a></p></li><li><p>发送HTTP请求<br>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p></li><li><p>服务器接受请求并返回HTTP响应<br>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p></li><li><p>释放连接TCP连接<br>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p></li><li><p>客户端浏览器解析HTML内容<br>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p></li></ol><p>在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p><ul><li><ol><li>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</li></ol></li><li><ol start="2"><li>解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;</li></ol></li><li><ol start="3"><li>浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次</li></ol></li><li><ol start="4"><li>握手的第三个报文的数据发送给服务器;</li></ol></li><li><ol start="5"><li>服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</li></ol></li><li><ol start="6"><li>释放 TCP连接;</li></ol></li><li><ol start="7"><li>浏览器将该 html 文本并显示内容; 　</li></ol></li></ul><h3 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h3><p>HTTP/1.1协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源：</p><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><p>向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。</p><h4 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h4><p>与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。</p><h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><p>向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。</p><h4 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h4><p>向指定资源位置上传其最新内容。</p><h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><p>请求服务器删除Request-URI所标识的资源。</p><h4 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h4><p>回显服务器收到的请求，主要用于测试或诊断。</p><h4 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h4><p>这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用’*’来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。</p><h4 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h4><p>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。</p><p>注意事项：</p><ul><li>方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。</li><li>HTTP服务器至少应该实现GET和HEAD方法，其他方法都是可选的。当然，所有的方法支持的实现都应当匹配下述的方法各自的语义定义。此外，除了上述方法，特定的HTTP服务器还能够扩展自定义的方法。例如PATCH（由 RFC 5789 指定的方法）用于将局部修改应用到资源。</li></ul><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p>所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。</p><p>状态代码的第一个数字代表当前响应的类型：</p><ul><li>1xx消息——请求已被服务器接收，继续处理</li><li>2xx成功——请求已成功被服务器接收、理解、并接受</li><li>3xx重定向——需要后续操作才能完成这一请求</li><li>4xx请求错误——请求含有词法错误或者无法被执行</li><li>5xx服务器错误——服务器在处理某个正确请求时发生错误</li></ul><p>虽然 RFC 2616 中已经推荐了描述状态的短语，例如”200 OK”，”404 Not Found”，但是WEB开发者仍然能够自行决定采用何种短语，用以显示本地化的状态描述或者自定义信息。</p><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>超文本传输协议（HTTP）的统一资源定位符将从因特网获取信息的五个基本元素包括在一个简单的地址中：</p><ul><li><p>传送协议。</p></li><li><p>层级URL标记符号(为[//],固定不变)</p></li><li><p>访问资源需要的凭证信息（可省略）</p></li><li><p>服务器。（通常为域名，有时为IP地址）</p></li><li><p>端口号。（以数字方式表示，若为HTTP的默认值“:80”可省略）</p></li><li><p>路径。（以“/”字符区别路径中的每一个目录名称）</p></li><li><p>查询。（GET模式的窗体参数，以“?”字符为起点，每个参数以“&amp;”隔开，再以“=”分开参数名称与数据，通常以UTF8的URL编码，避开字符冲突的问题）</p></li><li><p>片段。以“#”字符为起点</p></li></ul><p>以<a href="https://www.pitcoft.com:80/news/index.html?id=250&amp;page=1">https://www.pitcoft.com:80/news/index.html?id=250&amp;page=1</a> 为例, 其中：</p><p>http，是协议；<br><a href="http://www.pitcoft.com,是服务器;/">www.pitcoft.com，是服务器；</a><br>80，是服务器上的网络端口号；<br>/news/index.html，是路径；<br>?id=250&amp;page=1，是查询。<br>大多数网页浏览器不要求用户输入网页中“http://”的部分，因为绝大多数网页内容是超文本传输协议文件。同样，“80”是超文本传输协议文件的常用端口号，因此一般也不必写明。一般来说用户只要键入统一资源定位符的一部分（<a href="http://www.pitcoft.com/news/index.html?id=250&amp;page=1%EF%BC%89%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86%E3%80%82">www.pitcoft.com:80/news/index.html?id=250&amp;page=1）就可以了。</a></p><h3 id="HTTP请求格式"><a href="#HTTP请求格式" class="headerlink" title="HTTP请求格式"></a>HTTP请求格式</h3><p><img src="https://images2018.cnblogs.com/blog/867021/201803/867021-20180322001733298-201433635.jpg"></p><h3 id="HTTP响应格式"><a href="#HTTP响应格式" class="headerlink" title="HTTP响应格式"></a>HTTP响应格式</h3><p><img src="https://images2018.cnblogs.com/blog/867021/201803/867021-20180322001744323-654009411.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-143-重排链表</title>
    <link href="/2020/11/03/leetcode-143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/11/03/leetcode-143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>刷题笔记-leetcode 155.最小栈</title>
    <link href="/2020/10/31/leetcode-155-%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <url>/2020/10/31/leetcode-155-%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h3 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h3><p><a href="https://leetcode-cn.com/problems/min-stack/">https://leetcode-cn.com/problems/min-stack/</a></p><h3 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h3><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><ul><li><code>push(x)</code> —— 将元素 x 推入栈中。</li><li><code>pop()</code> —— 删除栈顶的元素。</li><li><code>top()</code> —— 获取栈顶元素。</li><li><code>getMin()</code> —— 检索栈中的最小元素。</li></ul><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><blockquote><p><strong>输入：</strong><br>[“MinStack”,”push”,”push”,”push”,”getMin”,”pop”,”top”,”getMin”]<br>[[],[-2],[0],[-3],[],[],[],[]]</p><p><strong>输出：</strong><br>[null,null,null,null,-3,null,0,-2]</p><p><strong>解释：</strong><br>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.</p></blockquote><p><strong>提示：</strong></p><ul><li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用。</li></ul><h3 id="方法一：快慢指针（一次遍历）"><a href="#方法一：快慢指针（一次遍历）" class="headerlink" title="方法一：快慢指针（一次遍历）"></a>方法一：快慢指针（一次遍历）</h3><h4 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h4><p>题目需求是寻找倒数第n个节点，所以我们可以设置两个指针<code>slow</code>和<code>fast</code>对链表进行遍历，<code>fast</code>先走n步的，当<code>fast</code>走到链表末尾时，<code>slow</code>正好为待删除节点的前驱节点。</p><p><strong>具体操作：</strong></p><ul><li>初始<code>slow</code>和<code>fast</code>指针均指向哑节点。</li><li>先使用<code>fast</code>指针遍历n次链表，即<code>fast</code>指针与<code>slow</code>指针相隔n-1个节点。</li><li>再同时使用<code>fast</code>指针和<code>slow</code>指针遍历链表，当<code>fast</code>遍历到链表的末尾时（即<code>fast.next</code>为空指针），<code>slow</code>为倒数第n个节点的前驱节点（即<code>slow.next</code>为待删除节点）。</li></ul><h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><p>时间复杂度：$O(1)$<br>空间复杂度：$O(N)$</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        self.stack = []        self.assist = [] <span class="hljs-comment"># 定义辅助栈</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span>(<span class="hljs-params">self, x: int</span>) -&gt; <span class="hljs-keyword">None</span>:</span>        self.stack.append(x)        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.assist <span class="hljs-keyword">or</span> x &lt;= self.assist[<span class="hljs-number">-1</span>]: <span class="hljs-comment"># 始终压最小的数</span>            self.assist.append(x)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span>        <span class="hljs-keyword">if</span> self.stack.pop() == self.assist[<span class="hljs-number">-1</span>]: <span class="hljs-comment"># 执行stack.pop 判断是否与辅助栈最小值相等</span>            self.assist.pop()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top</span>(<span class="hljs-params">self</span>) -&gt; int:</span>        <span class="hljs-keyword">return</span> self.stack[<span class="hljs-number">-1</span>]    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getMin</span>(<span class="hljs-params">self</span>) -&gt; int:</span>        <span class="hljs-keyword">return</span> self.assist[<span class="hljs-number">-1</span>]</code></pre><h3 id="方法二：递归迭代"><a href="#方法二：递归迭代" class="headerlink" title="方法二：递归迭代"></a>方法二：递归迭代</h3><h4 id="思路分析：-1"><a href="#思路分析：-1" class="headerlink" title="思路分析："></a>思路分析：</h4><p>通过递归的函数<code>head.next= self.removeNthFromEnd(head.next, n)</code>从后往前计数，每次向前加一，如果<code>count != n</code>时，返回该节点<code>return head</code>，继续往前递归，当<code>count == n</code>时，返回该节点的<code>next</code>给递归的函数（也就是跳过待删除函数，传递的是待删除的函数的<code>next</code>）。</p><h4 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><p>时间复杂度：$O(L)$，<code>L</code>为该链表长度。<br>空间复杂度：$O(1)$，一次遍历。</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">removeNthFromEnd</span>(<span class="hljs-params">self, head: ListNode, n: int</span>) -&gt; ListNode:</span>        <span class="hljs-keyword">global</span> count <span class="hljs-comment"># 递归时count要赋值</span>        <span class="hljs-keyword">if</span> head <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            count = <span class="hljs-number">0</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        <span class="hljs-keyword">else</span>:            head.next= self.removeNthFromEnd(head.next, n) <span class="hljs-comment"># 递归调用</span>            count += <span class="hljs-number">1</span> <span class="hljs-comment"># 回溯时节点的计数</span>            <span class="hljs-keyword">return</span> head.next <span class="hljs-keyword">if</span> count ==n <span class="hljs-keyword">else</span> head <span class="hljs-comment"># 删除节点</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>设计</tag>
      
      <tag>辅助栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>刷题笔记-leetcode 925.长按键入</title>
    <link href="/2020/10/30/leetcode-925-%E9%95%BF%E6%8C%89%E9%94%AE%E5%85%A5/"/>
    <url>/2020/10/30/leetcode-925-%E9%95%BF%E6%8C%89%E9%94%AE%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h3><p><a href="https://leetcode-cn.com/problems/long-pressed-name/">https://leetcode-cn.com/problems/long-pressed-name/</a></p><h3 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h3><p>你的朋友正在使用键盘输入他的名字 <code>name</code>。偶尔，在键入字符 <code>c</code> 时，按键可能会被长按，而字符可能被输入 1 次或多次。</p><p>你将会检查键盘输入的字符 <code>typed</code>。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 <code>True</code>。</p><h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><blockquote><p><strong>输入</strong>：name = “alex”, typed = “aaleex”<br><strong>输出</strong>：true<br><strong>解释</strong>：’alex’ 中的 ‘a’ 和 ‘e’ 被长按。</p></blockquote><h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><blockquote><p><strong>输入</strong>：name = “saeed”, typed = “ssaaedd”<br><strong>输出</strong>：false<br><strong>解释</strong>：’e’ 一定需要被键入两次，但在 typed 的输出中不是这样。</p></blockquote><h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h4><blockquote><p><strong>输入</strong>：name = “leelee”, typed = “lleeelee”<br><strong>输出</strong>：true</p></blockquote><h4 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a>示例 4：</h4><blockquote><p><strong>输入</strong>：name = “laiden”, typed = “laiden”<br><strong>输出</strong>：ture<br><strong>解释</strong>：长按名字中的字符并不是必要的。</p></blockquote><h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h4><ol><li><code>name.length &lt;= 1000</code></li><li><code>typed.length &lt;= 1000</code></li><li><code>name</code> 和 <code>typed</code> 的字符都是小写字母。</li></ol><h3 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h3><h4 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h4><p>题意为<code>name</code>为正常输入，<code>typed</code>可能存在某个字符长按连续键入多次。即需求为判断<code>typed</code>是长按连续键入还是错误键入。</p><p>可以用双指针分别遍历<code>name</code>和<code>typed</code>，判断两者是否符合条件，具体思路为：</p><ul><li>定义<code>p</code>，<code>q</code>两个指针，分别指向<code>name</code>和<code>typed</code>字符串的首个字符。</li><li>当两者指针指向同一个字符时，说明字符匹配，<code>p</code>，<code>q</code>都往后移动一个字符。</li><li>当两者指针指向字符不匹配，分两种情况：<ul><li>如果<code>q</code>指针指向字符<strong>等于</strong><code>q</code>指针后移一位指向的字符，表示该字符是<strong>连续键入</strong>。</li><li>如果<code>q</code>指针指向字符<strong>不等于</strong><code>q</code>指针后移一位指向的字符，表示该字符是<strong>错误键入</strong>。</li></ul></li><li>最后判断当<code>j=0</code>时即跳出循环时，<code>typed</code>已经遍历完，而<code>name</code>仍未遍历完，两者必不相等，直接返回<code>False</code>。</li></ul><h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><p>时间复杂度：$O(M+N)$，分别遍历<code>name</code>和<code>typed</code>两个字符串。<br>空间复杂度：$O(1)$，常数个辅助变量。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isLongPressedName</span>(<span class="hljs-params">self, name: str, typed: str</span>) -&gt; bool:</span>        m, n = len(name), len(typed)        <span class="hljs-comment"># 定义两个指针，分别指向name和typed的首字符</span>        i, j = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>        <span class="hljs-comment"># 遍历typed到尾字符</span>        <span class="hljs-keyword">while</span> j &lt; n:            <span class="hljs-comment"># 两个指针同时指向字符相等，两指针后移</span>            <span class="hljs-keyword">if</span> i &lt; m <span class="hljs-keyword">and</span> name[i] == typed[j]:                i += <span class="hljs-number">1</span>                j += <span class="hljs-number">1</span>            <span class="hljs-comment"># j = 0时不满足首字符相等，name和typed首字符不相等，直接返回False</span>            <span class="hljs-comment"># j &gt; 0时指针指向字符等于下一个字符，j指针后移，继续判断</span>            <span class="hljs-comment"># j &gt; 0时指针指向字符不等于下一个字符，代表错误输入了字符，直接返回False</span>            <span class="hljs-keyword">elif</span> j &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> typed[j] == typed[j<span class="hljs-number">-1</span>]:                j += <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-comment"># 最后跳出循环(代表typed已经遍历完了)，判断name是否遍历完，完则True，否则返回False。</span>        <span class="hljs-keyword">return</span> i == m</code></pre><h3 id="方法二：单指针"><a href="#方法二：单指针" class="headerlink" title="方法二：单指针"></a>方法二：单指针</h3><h4 id="思路分析：-1"><a href="#思路分析：-1" class="headerlink" title="思路分析："></a>思路分析：</h4><p>题目说明name和typed均为小写字母，设置一个单指针，指向<code>typed</code>首字符，用<code>i</code>表示name字符的索引，具体步骤：</p><ul><li>遍历<code>typed</code>，字符串<code>type</code>与<code>name</code>对应字符相等，则<code>i</code>加一，继续遍历<code>typed</code>。</li><li>当字符串<code>type</code>与<code>name</code>对应字符<strong>不相等</strong>，则：<ul><li>当前字符与前一个字符<strong>相等</strong>，表示该字符是<strong>连续键入</strong>，继续往后遍历。</li><li>当前字符与前一个字符<strong>不相等</strong>，表示该字符是<strong>错误键入</strong>，直接返回False。</li></ul></li><li>最后<code>typed</code>遍历结束时，判断<code>name</code>是否走完，若<code>name</code>仍未遍历完，两者必不相等，直接返回<code>False</code>。</li></ul><blockquote><p>例子：name = “pitcoft”, typed = “pit”</p></blockquote><p><strong>注意边界问题</strong>：</p><blockquote><p>例子：name = “a”, typed = “aaa”</p></blockquote><ul><li><strong>问题</strong>：如果按以上执行此例子，会报错，原因是第一个字符匹配后，<code>i = 1</code>，导致下一次判断<code>name[1]</code>不存在。</li><li><strong>解决办法</strong>：在<code>name</code>后面加上一个辅助字符串<code>“$”</code>，这样<code>i = 1</code>时能读取到<code>“$”</code>进而满足<code>type = name[i-1]</code>。</li></ul><h4 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><p>时间复杂度：$O(M+N)$，分别遍历<code>S</code>和<code>T</code>两个字符串<br>空间复杂度：$O(1)$</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isLongPressedName</span>(<span class="hljs-params">self, name: str, typed: str</span>) -&gt; bool:</span>        i = <span class="hljs-number">0</span>         name += <span class="hljs-string">&quot;$&quot;</span>        <span class="hljs-keyword">for</span> type <span class="hljs-keyword">in</span> typed:            <span class="hljs-keyword">if</span> type == name[i]:<span class="hljs-comment"># 当前字符相等，后移继续判断</span>                i += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> type != name[i<span class="hljs-number">-1</span>]:<span class="hljs-comment"># 当前字符与前一位不等，直接返回False，相等则继续判断</span>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> i == len(name) - <span class="hljs-number">1</span> <span class="hljs-comment">#减一是因为加了辅助的$</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>刷题笔记-leetcode 561.数组拆分I</title>
    <link href="/2020/10/27/leetcode-561-%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86-I/"/>
    <url>/2020/10/27/leetcode-561-%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86-I/</url>
    
    <content type="html"><![CDATA[<h3 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h3><p><a href="https://leetcode-cn.com/problems/array-partition-i/">https://leetcode-cn.com/problems/array-partition-i/</a></p><h3 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h3><p>给定长度为 <strong>2n</strong> 的数组, 你的任务是将这些数分成 <strong>n</strong> 对, 例如 <strong>(a1, b1), (a2, b2), …, (an, bn)</strong> ，使得从1 到 n 的 <strong>min(ai, bi)</strong> 总和最大。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><blockquote><p><strong>输入</strong> : [1,4,3,2]</p><p><strong>输出</strong> : 4<br><strong>解释</strong> : n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4).</p></blockquote><p><strong>提示：</strong></p><pre><code>1. n 是正整数,范围在 [1, 10000].2. 数组中的元素范围在 [-10000, 10000].</code></pre><h3 id="方法：数组排序"><a href="#方法：数组排序" class="headerlink" title="方法：数组排序"></a>方法：数组排序</h3><h4 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h4><p>题目需求是将长度2n的数组拆成n对，在每个队里取最小值，然后相加取得一个最大值。</p><p>例如：<code>[1,4,3,2]</code>拆成2对，与最小数<code>1</code>匹配的数，<code>1</code>是一定可以取到的，与最大数<code>4</code>匹配，取到的一定是另外的数。</p><ul><li>所以要达到收益最大化，必须为最小数匹配第二小的数；最大数匹配第二大的数。</li></ul><p><strong>具体操作：</strong></p><ul><li>做数组的原地快速排序。</li><li>取下标为偶数的值求和即可。</li></ul><h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><p><code>sorted</code>函数内部实现机制为：<code>Timsort</code></p><p>时间复杂度：$O(nlog(n))$，<code>Timsort</code>算法的时间复杂度。<br>空间复杂度：$O(n)$</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arrayPairSum</span>(<span class="hljs-params">self, nums: List[int]</span>) -&gt; int:</span>        sum = <span class="hljs-number">0</span>        nums.sort()        <span class="hljs-keyword">for</span> i,item <span class="hljs-keyword">in</span> enumerate(nums):            <span class="hljs-keyword">if</span> i%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>: <span class="hljs-comment"># 取下标为偶数的值</span>                sum += item <span class="hljs-comment"># 求和</span>        <span class="hljs-keyword">return</span> sum</code></pre><h4 id="精简代码："><a href="#精简代码：" class="headerlink" title="精简代码："></a>精简代码：</h4><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">arrayPairSum</span>(<span class="hljs-params">self, nums</span>) -&gt; int:</span>        <span class="hljs-keyword">return</span> sum(sorted(nums)[::<span class="hljs-number">2</span>]) <span class="hljs-comment"># 对数组排序，隔2取一个数并求和</span></code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>与最大与第二大匹配就可以保留第二大的数字（目的就是尽量保留大的数）</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>刷题笔记-leetcode 19.删除链表的倒数第N个节点</title>
    <link href="/2020/10/26/leetcode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <url>/2020/10/26/leetcode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h3><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</a></p><h3 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h3><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><blockquote><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p></blockquote><p><strong>说明：</strong><br>    给定的 n 保证是有效的。<br><strong>进阶：</strong><br>    你能尝试使用一趟扫描实现吗？</p><h3 id="方法一：快慢指针（一次遍历）"><a href="#方法一：快慢指针（一次遍历）" class="headerlink" title="方法一：快慢指针（一次遍历）"></a>方法一：快慢指针（一次遍历）</h3><h4 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h4><p>题目需求是寻找倒数第n个节点，所以我们可以设置两个指针<code>slow</code>和<code>fast</code>对链表进行遍历，<code>fast</code>先走n步的，当<code>fast</code>走到链表末尾时，<code>slow</code>正好为待删除节点的前驱节点。</p><p><strong>具体操作：</strong></p><ul><li>初始<code>slow</code>和<code>fast</code>指针均指向哑节点。</li><li>先使用<code>fast</code>指针遍历n次链表，即<code>fast</code>指针与<code>slow</code>指针相隔n-1个节点。</li><li>再同时使用<code>fast</code>指针和<code>slow</code>指针遍历链表，当<code>fast</code>遍历到链表的末尾时（即<code>fast.next</code>为空指针），<code>slow</code>为倒数第n个节点的前驱节点（即<code>slow.next</code>为待删除节点）。</li></ul><h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><p>时间复杂度：$O(L)$，<code>L</code>为该链表长度。<br>空间复杂度：$O(1)$，一次遍历。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">removeNthFromEnd</span>(<span class="hljs-params">self, head: ListNode, n: int</span>) -&gt; ListNode:</span>        dummy = ListNode(<span class="hljs-number">0</span>) <span class="hljs-comment"># 设置哑节点</span>        dummy.next = head        slow, fast = dummy, dummy <span class="hljs-comment"># 快慢指针指向哑节点</span>        <span class="hljs-comment"># 快指针先走n步</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):            fast = fast.next        <span class="hljs-comment"># 快慢指针同时走，直到fast指针到链表尾部，slow为待删除节点前驱节点</span>        <span class="hljs-keyword">while</span> fast.next:            slow = slow.next            fast = fast.next        <span class="hljs-comment"># 删除节点</span>        slow.next = slow.next.next        <span class="hljs-keyword">return</span> dummy.next</code></pre><h3 id="方法二：递归迭代"><a href="#方法二：递归迭代" class="headerlink" title="方法二：递归迭代"></a>方法二：递归迭代</h3><h4 id="思路分析：-1"><a href="#思路分析：-1" class="headerlink" title="思路分析："></a>思路分析：</h4><p>通过递归的函数<code>head.next= self.removeNthFromEnd(head.next, n)</code>从后往前计数，每次向前加一，如果<code>count != n</code>时，返回该节点<code>return head</code>，继续往前递归，当<code>count == n</code>时，返回该节点的<code>next</code>给递归的函数（也就是跳过待删除函数，传递的是待删除的函数的<code>next</code>）。</p><h4 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><p>时间复杂度：$O(L)$，<code>L</code>为该链表长度。<br>空间复杂度：$O(1)$，一次遍历。</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">removeNthFromEnd</span>(<span class="hljs-params">self, head: ListNode, n: int</span>) -&gt; ListNode:</span>        <span class="hljs-keyword">global</span> count <span class="hljs-comment"># 递归时count要赋值</span>        <span class="hljs-keyword">if</span> head <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            count = <span class="hljs-number">0</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        <span class="hljs-keyword">else</span>:            head.next= self.removeNthFromEnd(head.next, n) <span class="hljs-comment"># 递归调用</span>            count += <span class="hljs-number">1</span> <span class="hljs-comment"># 回溯时节点的计数</span>            <span class="hljs-keyword">return</span> head.next <span class="hljs-keyword">if</span> count ==n <span class="hljs-keyword">else</span> head <span class="hljs-comment"># 删除节点</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>双指针</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>刷题笔记-leetcode 844.比较含退格的字符串</title>
    <link href="/2020/10/20/leetcode-844-%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2020/10/20/leetcode-844-%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h3><p><a href="https://leetcode-cn.com/problems/backspace-string-compare/">https://leetcode-cn.com/problems/backspace-string-compare/</a></p><h3 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h3><p>给定 <code>S</code> 和 <code>T</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 <code>#</code> 代表退格字符。</p><p><strong>注意</strong>：如果对空文本输入退格字符，文本继续为空。</p><h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><blockquote><p>输入：S = “ab#c”, T = “ad#c”<br>输出：true<br>解释：S 和 T 都会变成 “ac”。</p></blockquote><h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><blockquote><p>输入：S = “ab##”, T = “c#d#”<br>输出：true<br>解释：S 和 T 都会变成 “”。</p></blockquote><h4 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h4><blockquote><p>输入：S = “a##c”, T = “#a#c”<br>输出：true<br>解释：S 和 T 都会变成 “c”。</p></blockquote><h4 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a>示例 4：</h4><blockquote><p>输入：S = “a#c”, T = “b”<br>输出：false<br>解释：S 会变成 “c”，但 T 仍然是 “b”。</p></blockquote><h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h4><p><code>1 &lt;= S.length &lt;= 200</code><br><code>1 &lt;= T.length &lt;= 200</code><br><code>S</code> 和 <code>T</code> 只含有小写字母以及字符<code> &#39;#&#39;</code>。</p><h3 id="方法一：字符串重构（栈）"><a href="#方法一：字符串重构（栈）" class="headerlink" title="方法一：字符串重构（栈）"></a>方法一：字符串重构（栈）</h3><h4 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h4><p>当字符串碰见退格符<code>#</code>的时，将退格符与前一个字符串一并删除，最终返回删除后的字符串并比较两个字符串是否相等，当遍历字符串时：</p><ul><li>如果是一般的字符，则压栈。</li><li>如果是退格符<code>#</code>，则把栈顶元素弹出。</li><li>遍历结束把栈元素用<code>join</code>函数连接成字符串</li></ul><h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><p>时间复杂度：$O(M+N)$，分别遍历<code>S</code>和<code>T</code>两个字符串<br>空间复杂度：$O(M+N)$</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params">object</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backspaceCompare</span>(<span class="hljs-params">self, S, T</span>):</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inputStr</span>(<span class="hljs-params">str</span>):</span>            stack = list()            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> str:                <span class="hljs-comment"># 判断为普通字符则压栈</span>                <span class="hljs-keyword">if</span> i != <span class="hljs-string">&#x27;#&#x27;</span>:                    stack.append(i)                <span class="hljs-comment"># 为#且栈不为空则栈顶出栈</span>                <span class="hljs-keyword">elif</span> stack != []:                    stack.pop()            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(stack[:])        <span class="hljs-keyword">return</span> inputStr(S) == inputStr(T)</code></pre><h3 id="方法二：双指针"><a href="#方法二：双指针" class="headerlink" title="方法二：双指针"></a>方法二：双指针</h3><h4 id="思路分析：-1"><a href="#思路分析：-1" class="headerlink" title="思路分析："></a>思路分析：</h4><p>当遇见<code>#</code>字符时，会删除其前一个字符，也就是说，<code>#</code>的影响仅限于删除它的前一个字符而不会影响到其他字符，因此我们可以用逆序遍历整个字符串，当存在<code>#</code>字符时，就可以判断是否要删除前一个字符。具体步骤：</p><ol><li><p>定义双指针，分别指向<code>S</code>和<code>T</code>两个字符串的末尾。</p></li><li><p>定义变量count，记录<code>#</code>出现的次数（也就是待删除元素的数量）。</p><p>遍历字符串的每一个字符，如果该字符：</p></li></ol><ul><li>为<code>#</code>字符，则记录的变量count加1</li><li>为普通字符，则：<ul><li>count = 0时，表示该字符不需要删除。</li><li>count &gt; 0时，该字符删除，并且count减1。</li></ul></li></ul><p>按以上逆序遍历两个字符串，会碰见以下三种情况：</p><ul><li>count为0，且两个指针同时指向普通字符，判断两字符是否相等，不等返回False，相等继续判断。<pre><code class="hljs python"><span class="hljs-keyword">if</span> p &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> q &gt;= <span class="hljs-number">0</span>:<span class="hljs-keyword">if</span> S[p] != T[q]:<span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></li><li>当一个字符串遍历完成，代表该字符串为“ ”，条件为<code>p &lt; 0 or q &lt; 0</code>，并且另一个字符串仍未遍历完（也就是已经跳出循环，处于在等待判断普通字符是否与另一个字符串相等的阶段），这时候两个字符串是不可能相等的（一个空，另一个的字符串在等待判断）,直接返回<code>False</code>。<pre><code class="hljs python"><span class="hljs-keyword">elif</span> p &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> q &gt;= <span class="hljs-number">0</span>:<span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></li><li>两个字符串遍历完成，则<code>p</code>与<code>q</code>都 &lt; 0，代表字符串都为“ ”。返回<code>True</code>。</li></ul><h4 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><p>时间复杂度：$O(M+N)$，分别遍历<code>S</code>和<code>T</code>两个字符串<br>空间复杂度：$O(1)$</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backspaceCompare</span>(<span class="hljs-params">self, S: str, T: str</span>) -&gt; bool:</span>        <span class="hljs-comment"># 定义双指针</span>        p, q = len(S) - <span class="hljs-number">1</span>, len(T) - <span class="hljs-number">1</span>        <span class="hljs-comment"># 定义变量记录 &#x27;#&#x27; 的数量</span>        count_S, count_T = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> p &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> q &gt;= <span class="hljs-number">0</span>:            <span class="hljs-comment"># 遍历字符串 S</span>            <span class="hljs-keyword">while</span> p &gt;= <span class="hljs-number">0</span>:                <span class="hljs-comment"># 字符为 &#x27;#&#x27;，count_S 加 1，p指针左移</span>                <span class="hljs-keyword">if</span> S[p] == <span class="hljs-string">&#x27;#&#x27;</span>:                    count_S += <span class="hljs-number">1</span>                    p -= <span class="hljs-number">1</span>                <span class="hljs-comment"># 字符为普通字符，count_S&gt;0，删除该字符，count_S，p左移继续遍历</span>                <span class="hljs-keyword">elif</span> count_S &gt; <span class="hljs-number">0</span>:                    count_S -= <span class="hljs-number">1</span>                    p -= <span class="hljs-number">1</span>                <span class="hljs-comment"># 字符为普通字符，count_S=0，跳出循环，等待与另一个字符串判断</span>                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">break</span>            <span class="hljs-comment"># 遍历字符串 T</span>            <span class="hljs-keyword">while</span> q &gt;= <span class="hljs-number">0</span>:                <span class="hljs-keyword">if</span> T[q] == <span class="hljs-string">&#x27;#&#x27;</span>:                    count_T += <span class="hljs-number">1</span>                    q -= <span class="hljs-number">1</span>                <span class="hljs-keyword">elif</span> count_T &gt; <span class="hljs-number">0</span>:                    count_T -= <span class="hljs-number">1</span>                    q -= <span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">break</span>            <span class="hljs-comment"># 判断字符串两个未遍历完，跳出循环时，两个指针对应的字符是否相等</span>            <span class="hljs-keyword">if</span> p &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> q &gt;= <span class="hljs-number">0</span>:                <span class="hljs-keyword">if</span> S[p] != T[q]:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-comment"># 只有一个字符串遍历完，另一个跳出循环</span>            <span class="hljs-keyword">elif</span> p &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> q &gt;= <span class="hljs-number">0</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            p -= <span class="hljs-number">1</span>            q -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
